set nocompatible               " Be iMproved
if has('vim_starting')
    set runtimepath+=~/.vim/bundle/neobundle.vim/ " Required
endif

call neobundle#begin(expand('~/.vim/bundle/')) " Required

" Let NeoBundle manage NeoBundle
NeoBundleFetch 'Shougo/neobundle.vim' " Required

NeoBundle 'Shougo/vimproc.vim', {
        \ 'build' : {
        \     'windows' : 'tools\\update-dll-mingw',
        \     'cygwin' : 'make -f make_cygwin.mak',
        \     'mac' : 'make -f make_mac.mak',
        \     'unix' : 'make -f make_unix.mak',
        \    },
        \ }
NeoBundle 'scrooloose/nerdtree'
NeoBundle 'godlygeek/tabular.git'
NeoBundle 'tpope/vim-commentary'
NeoBundle 'tpope/vim-git.git'
NeoBundle 'tpope/vim-fugitive.git'
NeoBundle 'Yggdroot/indentLine.git'
NeoBundle 'terryma/vim-expand-region.git'
"bufkill: Gives the :BD command(s) to keep window layout when deleting buffers
NeoBundle 'bufkill.vim'
NeoBundle 'BufOnly.vim'  " :BufOnly command
NeoBundle 'scrooloose/syntastic.git'
NeoBundle 'majutsushi/tagbar'
" repeat.vim allows other plugins to use the dot repeat command
NeoBundle 'tpope/vim-repeat.git'
NeoBundle 'tpope/vim-surround.git'
NeoBundle 'bling/vim-airline.git'
NeoBundle 'yssl/QFEnter.git'  " open quickfix item in last focused window
NeoBundle 'mtth/scratch.vim'
" tern complete's javascript
NeoBundle 'marijnh/tern_for_vim'
NeoBundle 'jelera/vim-javascript-syntax'
NeoBundle 'pangloss/vim-javascript'
" NeoBundle 'klen/python-mode'
NeoBundle 'davidhalter/jedi-vim'
" sherlock performs completion from current buffer for command line line mode
" by using ctrl-tab and ctrl-shift-tab
NeoBundle 'sherlock.vim'
NeoBundle 'bling/vim-bufferline'
NeoBundle 'christoomey/vim-tmux-navigator'
NeoBundle 'mhinz/vim-tmuxify'  " send commands to a tmux pane
NeoBundle 'kien/ctrlp.vim'
NeoBundle 'FelikZ/ctrlp-py-matcher.git'  " Faster ctrl-p matcher
NeoBundle 'rking/ag.vim'
NeoBundle 'airblade/vim-rooter.git'  " autochdir to project roots
" The following 2 work with vim-repeat and vim-surround
NeoBundle 'guns/vim-sexp.git'
NeoBundle 'tpope/vim-sexp-mappings-for-regular-people.git'

" Colors
NeoBundle 'molokai'
NeoBundle 'altercation/vim-colors-solarized.git'
" Defines commands :CP and :CN that change (next, prev) colorschemes
" Also defines :SCROLLCOLORS to provide a list of colorscheme choices
NeoBundle 'ScrollColors'
" Colors color expressions like their actual colors #FF0000
NeoBundle 'chrisbra/color_highlight.git'
NeoBundle 'guns/xterm-color-table.vim'

" Language Support
NeoBundle 'suan/vim-instant-markdown'
NeoBundle 'kchmck/vim-coffee-script'
NeoBundle 'mustache/vim-mustache-handlebars'
NeoBundle 'othree/html5.vim'
NeoBundle 'neo4j-contrib/cypher-vim-syntax'
NeoBundle 'chase/vim-ansible-yaml'

NeoBundle 'xolox/vim-misc'     " required for vim-session
NeoBundle 'xolox/vim-session'  " better session management

"""""""""" To Try """"""""""""""
" NeoBundle 'xolox/vim-notes'
" NeoBundle 'kien/rainbow_parentheses.vim'
" NeoBundle 'Xuyuanp/nerdtree-git-plugin'
" NeoBundle 'lilydjwg/colorizer' " like color_highlight
" NeoBundle 'airblade/vim-gitgutter'
" NeoBundle 'maksimr/vim-jsbeautify'
" NeoBundle 'beautify-web/js-beautify'
" http://thlorenz.github.io/replpad/
" NeoBundle 'sidorares/node-vim-debugger'
" NeoBundle 'jeetsukumaran/vim-buffergator'
" NeoBundle 'JazzCore/ctrlp-cmatcher'
" ahayman/vim-nodejs-complete
" moll/vim-node
" NeoBundle 'Shougo/neomru.vim'
" NeoBundle 'Shougo/unite.vim'
" NeoBundle 'Shougo/vimfiler.vim'  " requries unite
" NeoBundle 'rkulla/pydiction.git'
" NeoBundle '/xolox/vim-easytags'
""""""" Recently Retired """""""
" NeoBundle "jmcantrell/vim-virtualenv"
" NeoBundle 'nathanaelkane/vim-indent-guides.git'
" NeoBundle 'tpope/vim-markdown'
" NeoBundle 'JessicaKMcIntosh/TagmaBufMgr.git'
" vim-fontsize: <Leader><Leader>+ will enter "font size" mode
" NeoBundle 'drmikehenry/vim-fontsize'
" NeoBundle 'mileszs/ack.vim'
" NeoBundle 'Valloric/YouCompleteMe', {
"       \ 'build' : {
"       \     'mac' : './install.sh',
"       \    },
"       \ }
""""""""""""""""""""""""""""""""

call neobundle#end()

" Required:
filetype plugin indent on

" If there are uninstalled bundles found on startup,
" this will conveniently prompt you to install them.
NeoBundleCheck

"""""""""""""""""""""""""""""""""""""""""
" Standard VIM options
"""""""""""""""""""""""""""""""""""""""""
" set t_Co=256
set nu               "line numbers
syntax enable
syntax sync minlines=256  " for speed improvement
set synmaxcol=255  " speed for long lines
set cryptmethod=blowfish
set history=500 "lines of history
set showcmd
set hlsearch
set incsearch
set nowrap      " don't wrap text
set nowrapscan  " don't wrap search from bottom to top (and opposite)
"hi Search ctermbg=darkgreen ctermfg=white guibg=darkgreen guifg=white
"hi Visual ctermbg=darkgrey guibg=darkgrey
"hi MatchParen cterm=bold gui=bold guifg=black guibg=darkgrey
set laststatus=2 "always show the status line
set encoding=utf8
set nosmartindent " smartindent causes line-initial # mark to unintent
set cindent
" set tab stop to 4 spaces so tab spacing isnt so huge
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
"set autoindent
set shiftround " round indents to multiples of shiftwidth
set copyindent " copy structure of existing line indent
"set preserveindent
" no special treatment for '#' character when indenting
set cinkeys-=0#
set indentkeys-=0#
set undodir=~/.vim/undo
set undofile
set undolevels=1500 " max number of changes that can be undone
set undoreload=10000 " max number of lines to save for undo on a buffer reload
set linebreak
set textwidth=79
"set columns=88
set formatoptions-=t " unset automatic text wrapping at textwidth
set formatoptions+=n " recognized numbered lists
" number of lines to cursor
set scrolloff=3
" show matching brackets
set showmatch
set shortmess="atI"
"set cursorline " highlight current line
set ruler       " show line/col position
"set colorcolumn=+1 " colorcolumn textwidth+1
set colorcolumn=81 " colorcolumn textwidth+1
"set foldmethod=syntax
set foldlevelstart=20
set foldnestmax=3  " max nested level to fold
set backspace=indent,eol,start
"set ignorecase
"set smartcase     " ignore case if search pattern is all lowercase,
                  "    case-sensitive otherwise
set undolevels=1000  " use many muchos levels of undo
set list
" set listchars=tab:>.,trail:.,extends:#,nbsp:.
set listchars=tab:\|\ ,trail:.,extends:#,nbsp:.
" Add the '-' to the list of characters that are considered part of a keyword.
" IE. Word actions will include hyphenated words.
set iskeyword+=-
"if has('win32') || has('win64')
    "set shellslash
"endif
" set autochdir  " Automatically change CWD to file's directory.

set undodir=~/.vim/tmp/undo/ " undo files
set backupdir=~/.vim/tmp/backup/ " backups
set directory=~/.vim/tmp/swap/ " swap files

if !isdirectory(expand(&undodir))
call mkdir(expand(&undodir), "p")
endif
if !isdirectory(expand(&backupdir))
call mkdir(expand(&backupdir), "p")
endif
if !isdirectory(expand(&directory))
call mkdir(expand(&directory), "p")
endif

" Tab on the command line will show a menu to complete buffer and file names
set wildchar=<Tab> wildmenu wildmode=longest,list,full
set wildignore+=*.o,*.obj,.git,*.pyc,*.py~

set diffopt+=vertical

" enable mouse interaction when running in tmux or screen
set mouse+=a
if &term =~ '^screen'
    " tmux knows the extended mouse mode
    set ttymouse=xterm2
endif

" TODO: Play with this:
" vp doesn't replace paste buffer
" function! RestoreRegister()
"   let @" = s:restore_reg
"   return ''
" endfunction
" function! s:Repl()
"   let s:restore_reg = @"
"   return "p@=RestoreRegister()\<cr>"
" endfunction
" vmap <silent> <expr> p <sid>Repl()

" vim-session
let g:session_autoload='no'
let g:session_autosave='yes'
let g:session_autosave_periodic=5

" vim-tmuxify
let g:tmuxify_custom_command = 'tmux split-window -d -l 10'
" let g:tmuxify_map_prefix = '<leader>m'

" a Silent command that calls redraw automatically
command! -nargs=1 Silent
\ | execute ':silent !'.<q-args>
\ | execute ':redraw!'

"""""""""""""""""""""""""""""""""""""""""
" The Silver Searcher
if executable('ag')
  " Use ag over grep
  let g:aghighlight=1
  " set grepprg=ag\ --nogroup\ --nocolor\ --column
  " set grepformat=%f:%l:%c:%m,%f:%l:%m
  set grepprg=ag\ --vimgrep\ $*
  set grepformat=%f:%l:%c:%m
  " Use ag in CtrlP for listing files. Lightning fast and respects .gitignore
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
  " ag is fast enough that CtrlP doesn't need to cache
  let g:ctrlp_use_caching = 0
  " let g:ctrlp_cmd = 'CtrlP'
endif

let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
" let g:ctrlp_match_func = {'match' : 'matcher#cmatch' }
let g:ctrlp_working_path_mode = 'rw'
" let g:ctrlp_max_files = 0

" Ignore some folders and files for CtrlP indexing
let g:ctrlp_custom_ignore = {
  \ 'dir':  '\.git$\|\.yardoc\|tmp$\|node_modules$\|bower_components$',
  \ 'file': '.\(DS_Store\|so\|dat\|pdf\|epub\|rar\|png\|jpg\|dmg\|bz\|gz\|tar\|xib\|pyc\)$'
  \ }

" let g:rooter_use_lcd = 1
" let g:rooter_change_directory_for_non_project_files = 1
let g:rooter_patterns = ['.git', '.git/', '_darcs/', '.hg/', '.bzr/', '.svn/',
                        \ '.project', '.project/', '.vimrc']

" [line no] + <Enter> instead of [line no] + G
nnoremap <CR> G
nnoremap <BS> gg

nmap <leader>pb :CtrlPBuffer<CR>
nmap <leader>pp :CtrlP<CR>
nmap <leader>pm :CtrlPMixed<CR>
nmap <leader>pr :CtrlPMRUFiles<CR>

" Navigate the quickfix entries with arrow keys
nmap <silent> <RIGHT> :cnext<CR>
nmap <silent> <LEFT> :cprev<CR>

nmap <silent> <UP> :tabprevious<CR>
nmap <silent> <DOWN> :tabnext<CR>

" bind K to grep word under cursor
" nnoremap K :silent! grep! "\b<C-r><C-w>\b"<CR>:cwindow<CR>:redraw!<CR>
nnoremap <silent> K :Ag! <cword><CR>

let g:pwanderu="~/Development/Wanderu/"
let g:pnotes="~/Documents/Notebooks/"

function! AgDir(search, dir)
    exec 'Ag! '. a:search . " " . a:dir
endfunction

command! -nargs=1 AgW call AgDir(<args>, g:pwanderu)
command! -nargs=1 AgN call AgDir(<args>, g:pnotes)

function! GetVisual()
    let reg_save = getreg('"')
    let regtype_save = getregtype('"') let cb_save = &clipboard
    set clipboard&
    normal! ""gvy
    let selection = getreg('"')
    call setreg('"', reg_save, regtype_save)
    let &clipboard = cb_save
    return selection
endfunction

"grep visual selection
vnoremap K :<C-U>execute "Ag " . GetVisual()<CR>

"Grep for usages of the current file
nnoremap <leader>gcf :exec "Ag " . expand("%:t:r")<CR>

" bind \ (backward slash) to grep shortcut
" command! -nargs=+ -complete=file_in_path -bar Ag silent grep! <args>|cwindow|redraw!

" tern
let g:tern_map_keys=1
let g:tern_show_argument_hints='on_hold'

augroup custom_filetype_python
    autocmd!
    autocmd BufRead,BufNewFile *.wsgi set filetype=python
    autocmd BufRead,BufNewFile *.tac set filetype=python   " twisted app
    " Python multi-line string shortcut
    autocmd FileType python inoremap <buffer> #" """<cr>"""<Up>
    autocmd FileType python inoremap <buffer> #' '''<cr>'''<Up>
augroup END

" Don't hide the markup
augroup custom_filetype_markdown
    autocmd!
    autocmd BufRead,BufNewFile *.md set filetype=markdown
    autocmd FileType markdown setlocal conceallevel=0
    " autocmd FileType markdown setlocal conceallevel=0
augroup END

nnoremap <leader>cl :setlocal conceallevel=0<cr>

" nnoremap <leader><leader> :b

" vim-instant-markdown
"let g:instant_markdown_slow = 1
" Use command :InstantMarkdownPreview
let g:instant_markdown_autostart = 0

" map ctrl-w + [hjkl] to ctrl-[hjkl] to move around windows
" noremap <C-h> <C-w>h
" noremap <C-j> <C-w>j
" noremap <C-k> <C-w>k
" noremap <C-l> <C-w>l

" make j and k act by terminal line when dealing with wrapped text
map j gj
map k gk

nnoremap <SPACE> <Nop>
let mapleader = "\<Space>"
let g:mapleader = "\<Space>"
let maplocalleader = "\<Space>"
let g:maplocalleader = "\<Space>"

nnoremap <leader>qo :silent! botright copen 10<cr>
nnoremap <leader>lo :silent! lopen 10<cr>
nnoremap <leader>qc :silent! cclose<cr>
nnoremap <leader>lc :silent! lclose<cr>

" TagmaBufMgr
" don't map Ctrl+arrows to move around splits/buffers (default 1)
let g:TagmaBufMgrMapCArrow = 0
let g:TagmaBufMgrBufName="#####TB#####"
"""
noremap <leader>tb :MgrToggle<CR>

" YouCompleteMe
let g:ycm_register_as_syntastic_checker = 1 "default 1
let g:Show_diagnostics_ui = 1 "default 1
let g:ycm_enable_diagnostic_signs = 1
let g:ycm_enable_diagnostic_highlighting = 0
let g:ycm_always_populate_location_list = 1 "default 0
let g:ycm_open_loclist_on_ycm_diags = 1 "default 1
let g:ycm_complete_in_strings = 1 "default 1
let g:ycm_collect_identifiers_from_tags_files = 0 "default 0
let g:ycm_path_to_python_interpreter = '' "default ''
let g:ycm_server_use_vim_stdout = 0 "default 0 (logging to console)
let g:ycm_server_log_level = 'info' "default info
"where to search for .ycm_extra_conf.py if not found:
let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
let g:ycm_confirm_extra_conf = 1
"[ 'same-buffer', 'horizontal-split', 'vertical-split', 'new-tab' ]
let g:ycm_goto_buffer_command = 'same-buffer'
let g:ycm_filetype_whitelist = { '*': 1 }
let g:ycm_key_invoke_completion = '<C-Space>'

set completeopt=menuone,longest

" vim-commenter
nmap <leader>cm gcc
vmap <leader>cm gc

inoremap JJ <Esc>
vnoremap JJ <Esc>

" Highlight current word without jumping
nmap <leader>hs :let @/ = expand("<cword>")<CR>:set hlsearch<CR>
" Toggle highlight:
nmap <leader>hl :set hlsearch!<CR>
" Clear highlight
nmap <leader>hc :let @/ = ""<CR>
nmap <leader>w :w<CR>
nmap <leader>qu :q<CR>
nmap <leader>qa :qa<CR>
nmap <leader>r :so $MYVIMRC<CR>

" Copy/Paste to system clipboard
vmap <Leader>y "+y
vmap <Leader>d "+d
nmap <Leader>p "+p
nmap <Leader>P "+P
vmap <Leader>p "+p
vmap <Leader>P "+P

" 'terryma/vim-expand-region.git'
vmap v <Plug>(expand_region_expand)
vmap <C-v> <Plug>(expand_region_shrink)

" Horizonal scrolling with Ctrl-N, Ctrl-M
nnoremap <C-m> 2zl
nnoremap <C-n> 2zh

" Window resizing
noremap <leader><Up> 2<C-W>+
noremap <leader><Down> 2<C-W>-
noremap <leader><Left> 2<C-w><
noremap <leader><Right> 2<C-w>>

" Airline
let g:airline_theme='murmur'  " solarized
" let g:airline#extensions#tabline#enabled = 1
" let g:airline#extensions#tabline#show_buffers = 1
" let g:airline_left_sep='|'
" let g:airline_right_sep='|'
let g:airline_section_a='%#__accent_bold#%{airline#util#wrap(airline#parts#mode(),0)}%#__restore__#%{airline#util#append(airline#parts#paste(),0)}%{airline#util#append("",0)}%{airline#util#append(airline#parts#iminsert(),0)}'
let g:airline_section_b='B:%{airline#util#wrap(airline#extensions#branch#get_head(),0)}'
" c modified to show full path, max 50 chars
let g:airline_section_c='F:%<%.50F%m %#__accent_red#%{airline#util#wrap(airline#parts#readonly(),0)}%#__restore__#'
let g:airline_section_x='S:%{xolox#session#find_current_session()}'
let g:airline_section_y=''
let g:airline_section_z=''

nnoremap <leader>> :bnext<CR>
nnoremap <leader>< :bprevious<CR>

" Unite
" let g:unite_source_history_yank_enable = 1
" call unite#filters#matcher_default#use(['matcher_fuzzy'])
" nnoremap <leader>ut :<C-u>Unite -no-split -buffer-name=files   -start-insert file_rec/async:!<cr>
" nnoremap <leader>uf :<C-u>Unite -no-split -buffer-name=files   -start-insert file<cr>
" nnoremap <leader>um :<C-u>Unite -no-split -buffer-name=mru     -start-insert file_mru<cr>
" nnoremap <leader>uo :<C-u>Unite -no-split -buffer-name=outline -start-insert outline<cr>
" nnoremap <leader>uy :<C-u>Unite -no-split -buffer-name=yank    history/yank<cr>
" nnoremap <leader>ue :<C-u>Unite -no-split -buffer-name=buffer  buffer<cr>

" " Custom mappings for the unite buffer
" autocmd FileType unite call s:unite_settings()
" function! s:unite_settings()
"   " Play nice with supertab
"   let b:SuperTabDisabled=1
"   " Enable navigation with control-j and control-k in insert mode
"   " imap <buffer> <C-j>   <Plug>(unite_select_next_line)
"   " imap <buffer> <C-k>   <Plug>(unite_select_previous_line)
" endfunction

" Jedi
" let g:jedi#popup_on_dot = 0
" autocmd FileType python setlocal completeopt-=preview

" Syntastic
let g:syntastic_disabled_filetypes = ['html']
let g:syntastic_enable_signs = 1
let g:syntastic_enable_balloons=1
let g:syntastic_auto_loc_list=2 " 0, 1 (auto open & close) or 2 (auto close only)
"if set to 2, use the :Errors command to bring up the loc list
let g:syntastic_always_populate_loc_list=1
" if 0, use command :Errors to populate loc list
" if 0, use command :SyntasticSetLoclist to manually set
let g:syntastic_check_on_open=1
let g:syntastic_python_checkers=['flake8']
let g:syntastic_python_flake8_post_args='--ignore=E126,E127,E128,E201,E202,E203,
                                        \E221,E222,E225,E226,E241,E251,E271,E272'
" let g:syntastic_loc_list_height=5  " default 10
" let g:syntastic_java_javac_classpath="/usr/share/java/*"
" let g:syntastic_java_javac_classpath.=":~/Downloads/apps/neo4j-community-2.1.3/lib/*"
" Syntastic uses the quickfix list (location list?)
" ]L ]l [L [l moves to next/previous quickfix items

" VimFiler
let g:vimfiler_force_overwrite_statusline = 0
nmap <leader>vf :VimFiler -buffer-name=explorer
                        \ -split -simple -winwidth=35 -toggle -no-quit<CR>


" NerdTree
let g:NERDTreeChDirMode       = 2
let g:NERDTreeIgnore=['\.pyc$', '\~$', '.DS_Store$']
"let g:NERDTreeWinPos = "right"
nnoremap <silent> <leader>nt :NERDTreeFocus<CR>
nnoremap <silent> <leader>nc :NERDTreeClose<CR>
" Stop underlines from showing up on files in NerdTree
augroup au_nerdtree
    autocmd!
    autocmd FileType nerdtree hi Title gui=None
augroup END

" Tagbar      The j argument here _v_ is required to focus the cursor
nmap <silent> <leader>to :TagbarOpen j<CR>
nmap <silent> <leader>tc :TagbarClose<CR>
nmap <silent> <leader>tt :TagbarToggle<CR>

" Delete trailing white space
func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc

augroup trailws
    autocmd!
    autocmd BufWrite *.py :call DeleteTrailingWS()
    autocmd BufWrite *.js :call DeleteTrailingWS()
augroup END

func! DoSolarized()
    set background=dark
    let g:solarized_visibility="high"
    let g:solarized_contrast="high"
    colors solarized
    " Override Normal foreground and comment colors to something a bit
    " brighter. Mean for use with solarized
    hi Normal ctermfg=lightgray guifg=lightgray
    hi Comment ctermfg=darkgrey guifg=darkgrey
endfunc

if has('gui_running')
    set guioptions-=T  " no toolbar
    set guioptions-=m  " no menubar
    set lines=999 "maximize height
    if has('mac') " macvim only along with 'gui_mac' and 'macunix'
        " set guifont=Courier\ New:h12
        set guifont=Sauce\ Code\ Powerline\ Light:h12
        " Anonymous\ Pro:h12
        :call DoSolarized()
    else
        set guifont=Monaco\ 9
    endif
    " colors Tomorrow-Night-Bright
    if winwidth(0)<80
        set columns=110 "good default
    endif
else
    if ((&term)=~"rxvt") || ((&term)=~"screen")
        let g:solarized_termtrans = 1
        " let g:solarized_termcolors=256
        " if has('mac')
        "     let g:solarized_termcolors=16
        " endif
        :call DoSolarized()
    endif
endif

highlight ColorColumn ctermbg=24 guibg=#005f87

" formatting the current paragraph (or selection)
vnoremap <leader>f gq
nnoremap <leader>f gqap

" quick switch buffers with leader key
nnoremap <leader>1 :1b<CR>
nnoremap <leader>2 :2b<CR>
nnoremap <leader>3 :3b<CR>
nnoremap <leader>4 :4b<CR>
nnoremap <leader>5 :5b<CR>
nnoremap <leader>6 :6b<CR>
nnoremap <leader>7 :7b<CR>
nnoremap <leader>8 :8b<CR>
nnoremap <leader>9 :9b<CR>
nnoremap <leader>0 :10b<CR>

let g:quickfix_is_open = 0
function! QuickfixToggle()
    if g:quickfix_is_open
        cclose
        let g:quickfix_is_open = 0
        execute g:quickfix_return_to_window . "wincmd w"
    else
        let g:quickfix_return_to_window = winnr()
        copen
        let g:quickfix_is_open = 1
    endif
endfunction
nnoremap <leader>qf :call QuickfixToggle()<cr>

" From: http://vim.wikia.com/wiki/VimTip572
" Highlight all instances of word under cursor, when idle.
" Type z/ to toggle highlighting on/off.
nnoremap z/ :if AutoHighlightToggle()<Bar>set hls<Bar>endif<CR>
function! AutoHighlightToggle()
  let @/ = ''
  if exists('#auto_highlight')
    au! auto_highlight
    augroup! auto_highlight
    setl updatetime=4000
    echo 'Highlight current word: off'
    return 0
  else
    augroup auto_highlight
      au!
      au CursorHold * let @/ = '\V\<'.escape(expand('<cword>'), '\').'\>'
    augroup end
    setl updatetime=500
    echo 'Highlight current word: ON'
    return 1
  endif
endfunction

map <leader>H :call AutoHighlightToggle()<CR>
